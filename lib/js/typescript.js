'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
let tss = null;
let ts = null;

/**
 * @access private
 */
class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.compilerOptions = {
      module: 'commonjs',
      sourceMap: true,
      doSemanticChecks: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  compileSync(sourceCode, filePath) {
    tss = tss || require('@paulcbetts/typescript-simple');
    ts = ts || require('typescript');

    // NB: If you enable semantic checks with TSX, you're gonna have a
    //     Bad Time
    let extraOpts = { target: ts.ScriptTarget.ES6 };
    let isJsx = false;
    if (filePath.match(/\.tsx$/i)) {
      extraOpts.jsx = ts.JsxEmit.React;
      isJsx = true;
    }

    // NB: Work around TypeScriptSimple modifying the options object
    let compiler = new tss.TypeScriptSimple(Object.assign({}, this.compilerOptions, extraOpts), this.compilerOptions.doSemanticChecks && !isJsx);

    return {
      code: compiler.compile(sourceCode, _path2.default.basename(filePath)),
      mimeType: 'application/javascript'
    };
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwidHNzIiwidHMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsImNvbXBpbGVyT3B0aW9ucyIsIm1vZHVsZSIsInNvdXJjZU1hcCIsImRvU2VtYW50aWNDaGVja3MiLCJnZXRJbnB1dE1pbWVUeXBlcyIsImNvbXBpbGVTeW5jIiwic291cmNlQ29kZSIsImZpbGVQYXRoIiwicmVxdWlyZSIsImV4dHJhT3B0cyIsInRhcmdldCIsIlNjcmlwdFRhcmdldCIsIkVTNiIsImlzSnN4IiwibWF0Y2giLCJqc3giLCJKc3hFbWl0IiwiUmVhY3QiLCJjb21waWxlciIsIlR5cGVTY3JpcHRTaW1wbGUiLCJPYmplY3QiLCJhc3NpZ24iLCJjb2RlIiwiY29tcGlsZSIsImJhc2VuYW1lIiwibWltZVR5cGUiLCJnZXRDb21waWxlclZlcnNpb24iLCJ2ZXJzaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsaUJBQWlCLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsQ0FBdkI7QUFDQSxJQUFJQyxNQUFNLElBQVY7QUFDQSxJQUFJQyxLQUFLLElBQVQ7O0FBRUE7OztBQUdlLE1BQU1DLGtCQUFOLDBDQUFvRDtBQUNqRUMsZ0JBQWM7QUFDWjs7QUFFQSxTQUFLQyxlQUFMLEdBQXVCO0FBQ3JCQyxjQUFRLFVBRGE7QUFFckJDLGlCQUFXLElBRlU7QUFHckJDLHdCQUFrQjtBQUhHLEtBQXZCO0FBS0Q7O0FBRUQsU0FBT0MsaUJBQVAsR0FBMkI7QUFDekIsV0FBT1QsY0FBUDtBQUNEOztBQUVEVSxjQUFZQyxVQUFaLEVBQXdCQyxRQUF4QixFQUFrQztBQUNoQ1gsVUFBTUEsT0FBT1ksUUFBUSwrQkFBUixDQUFiO0FBQ0FYLFNBQUtBLE1BQU1XLFFBQVEsWUFBUixDQUFYOztBQUVBO0FBQ0E7QUFDQSxRQUFJQyxZQUFZLEVBQUNDLFFBQVFiLEdBQUdjLFlBQUgsQ0FBZ0JDLEdBQXpCLEVBQWhCO0FBQ0EsUUFBSUMsUUFBUSxLQUFaO0FBQ0EsUUFBSU4sU0FBU08sS0FBVCxDQUFlLFNBQWYsQ0FBSixFQUErQjtBQUM3QkwsZ0JBQVVNLEdBQVYsR0FBZ0JsQixHQUFHbUIsT0FBSCxDQUFXQyxLQUEzQjtBQUNBSixjQUFRLElBQVI7QUFDRDs7QUFFRDtBQUNBLFFBQUlLLFdBQVcsSUFBSXRCLElBQUl1QixnQkFBUixDQUNiQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLckIsZUFBdkIsRUFBd0NTLFNBQXhDLENBRGEsRUFFYixLQUFLVCxlQUFMLENBQXFCRyxnQkFBckIsSUFBeUMsQ0FBQ1UsS0FGN0IsQ0FBZjs7QUFJQSxXQUFPO0FBQ0xTLFlBQU1KLFNBQVNLLE9BQVQsQ0FBaUJqQixVQUFqQixFQUE2QixlQUFLa0IsUUFBTCxDQUFjakIsUUFBZCxDQUE3QixDQUREO0FBRUxrQixnQkFBVTtBQUZMLEtBQVA7QUFJRDs7QUFFREMsdUJBQXFCO0FBQ25CLFdBQU9sQixRQUFRLHlCQUFSLEVBQW1DbUIsT0FBMUM7QUFDRDtBQXpDZ0U7a0JBQTlDN0Isa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5jb25zdCBpbnB1dE1pbWVUeXBlcyA9IFsndGV4dC90eXBlc2NyaXB0JywgJ3RleHQvdHN4J107XG5sZXQgdHNzID0gbnVsbDtcbmxldCB0cyA9IG51bGw7XG5cbi8qKlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVTY3JpcHRDb21waWxlciBleHRlbmRzIFNpbXBsZUNvbXBpbGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNvbXBpbGVyT3B0aW9ucyA9IHtcbiAgICAgIG1vZHVsZTogJ2NvbW1vbmpzJyxcbiAgICAgIHNvdXJjZU1hcDogdHJ1ZSxcbiAgICAgIGRvU2VtYW50aWNDaGVja3M6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xuICAgIHJldHVybiBpbnB1dE1pbWVUeXBlcztcbiAgfVxuXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoKSB7XG4gICAgdHNzID0gdHNzIHx8IHJlcXVpcmUoJ0BwYXVsY2JldHRzL3R5cGVzY3JpcHQtc2ltcGxlJyk7XG4gICAgdHMgPSB0cyB8fCByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XG5cbiAgICAvLyBOQjogSWYgeW91IGVuYWJsZSBzZW1hbnRpYyBjaGVja3Mgd2l0aCBUU1gsIHlvdSdyZSBnb25uYSBoYXZlIGFcbiAgICAvLyAgICAgQmFkIFRpbWVcbiAgICBsZXQgZXh0cmFPcHRzID0ge3RhcmdldDogdHMuU2NyaXB0VGFyZ2V0LkVTNn07XG4gICAgbGV0IGlzSnN4ID0gZmFsc2U7XG4gICAgaWYgKGZpbGVQYXRoLm1hdGNoKC9cXC50c3gkL2kpKSB7XG4gICAgICBleHRyYU9wdHMuanN4ID0gdHMuSnN4RW1pdC5SZWFjdDtcbiAgICAgIGlzSnN4ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBOQjogV29yayBhcm91bmQgVHlwZVNjcmlwdFNpbXBsZSBtb2RpZnlpbmcgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IHRzcy5UeXBlU2NyaXB0U2ltcGxlKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMsIGV4dHJhT3B0cyksXG4gICAgICB0aGlzLmNvbXBpbGVyT3B0aW9ucy5kb1NlbWFudGljQ2hlY2tzICYmICFpc0pzeCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogY29tcGlsZXIuY29tcGlsZShzb3VyY2VDb2RlLCBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKSksXG4gICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgfTtcbiAgfVxuXG4gIGdldENvbXBpbGVyVmVyc2lvbigpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgndHlwZXNjcmlwdC9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICB9XG59XG4iXX0=