'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
let tss = null;
let ts = null;

/**
 * @access private
 */
class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.compilerOptions = {
      module: 'commonjs',
      sourceMap: true,
      doSemanticChecks: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  static getOutputMimeType() {
    return 'application/javascript';
  }

  compileSync(sourceCode, filePath) {
    tss = tss || require('@paulcbetts/typescript-simple');
    ts = ts || require('typescript');

    // NB: If you enable semantic checks with TSX, you're gonna have a
    //     Bad Time
    let extraOpts = { target: ts.ScriptTarget.ES6 };
    let isJsx = false;
    if (filePath.match(/\.tsx$/i)) {
      extraOpts.jsx = ts.JsxEmit.React;
      isJsx = true;
    }

    // NB: Work around TypeScriptSimple modifying the options object
    let compiler = new tss.TypeScriptSimple(Object.assign({}, this.compilerOptions, extraOpts), this.compilerOptions.doSemanticChecks && !isJsx);

    return {
      code: compiler.compile(sourceCode, _path2.default.basename(filePath)),
      mimeType: 'application/javascript'
    };
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwidHNzIiwidHMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsImNvbXBpbGVyT3B0aW9ucyIsIm1vZHVsZSIsInNvdXJjZU1hcCIsImRvU2VtYW50aWNDaGVja3MiLCJnZXRJbnB1dE1pbWVUeXBlcyIsImdldE91dHB1dE1pbWVUeXBlIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJyZXF1aXJlIiwiZXh0cmFPcHRzIiwidGFyZ2V0IiwiU2NyaXB0VGFyZ2V0IiwiRVM2IiwiaXNKc3giLCJtYXRjaCIsImpzeCIsIkpzeEVtaXQiLCJSZWFjdCIsImNvbXBpbGVyIiwiVHlwZVNjcmlwdFNpbXBsZSIsIk9iamVjdCIsImFzc2lnbiIsImNvZGUiLCJjb21waWxlIiwiYmFzZW5hbWUiLCJtaW1lVHlwZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxpQkFBaUIsQ0FBQyxpQkFBRCxFQUFvQixVQUFwQixDQUF2QjtBQUNBLElBQUlDLE1BQU0sSUFBVjtBQUNBLElBQUlDLEtBQUssSUFBVDs7QUFFQTs7O0FBR2UsTUFBTUMsa0JBQU4sMENBQW9EO0FBQ2pFQyxnQkFBYztBQUNaOztBQUVBLFNBQUtDLGVBQUwsR0FBdUI7QUFDckJDLGNBQVEsVUFEYTtBQUVyQkMsaUJBQVcsSUFGVTtBQUdyQkMsd0JBQWtCO0FBSEcsS0FBdkI7QUFLRDs7QUFFRCxTQUFPQyxpQkFBUCxHQUEyQjtBQUN6QixXQUFPVCxjQUFQO0FBQ0Q7O0FBRUQsU0FBT1UsaUJBQVAsR0FBMkI7QUFDekIsV0FBTyx3QkFBUDtBQUNEOztBQUVEQyxjQUFZQyxVQUFaLEVBQXdCQyxRQUF4QixFQUFrQztBQUNoQ1osVUFBTUEsT0FBT2EsUUFBUSwrQkFBUixDQUFiO0FBQ0FaLFNBQUtBLE1BQU1ZLFFBQVEsWUFBUixDQUFYOztBQUVBO0FBQ0E7QUFDQSxRQUFJQyxZQUFZLEVBQUNDLFFBQVFkLEdBQUdlLFlBQUgsQ0FBZ0JDLEdBQXpCLEVBQWhCO0FBQ0EsUUFBSUMsUUFBUSxLQUFaO0FBQ0EsUUFBSU4sU0FBU08sS0FBVCxDQUFlLFNBQWYsQ0FBSixFQUErQjtBQUM3QkwsZ0JBQVVNLEdBQVYsR0FBZ0JuQixHQUFHb0IsT0FBSCxDQUFXQyxLQUEzQjtBQUNBSixjQUFRLElBQVI7QUFDRDs7QUFFRDtBQUNBLFFBQUlLLFdBQVcsSUFBSXZCLElBQUl3QixnQkFBUixDQUNiQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLdEIsZUFBdkIsRUFBd0NVLFNBQXhDLENBRGEsRUFFYixLQUFLVixlQUFMLENBQXFCRyxnQkFBckIsSUFBeUMsQ0FBQ1csS0FGN0IsQ0FBZjs7QUFJQSxXQUFPO0FBQ0xTLFlBQU1KLFNBQVNLLE9BQVQsQ0FBaUJqQixVQUFqQixFQUE2QixlQUFLa0IsUUFBTCxDQUFjakIsUUFBZCxDQUE3QixDQUREO0FBRUxrQixnQkFBVTtBQUZMLEtBQVA7QUFJRDs7QUFFREMsdUJBQXFCO0FBQ25CLFdBQU9sQixRQUFRLHlCQUFSLEVBQW1DbUIsT0FBMUM7QUFDRDtBQTdDZ0U7a0JBQTlDOUIsa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5jb25zdCBpbnB1dE1pbWVUeXBlcyA9IFsndGV4dC90eXBlc2NyaXB0JywgJ3RleHQvdHN4J107XG5sZXQgdHNzID0gbnVsbDtcbmxldCB0cyA9IG51bGw7XG5cbi8qKlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVTY3JpcHRDb21waWxlciBleHRlbmRzIFNpbXBsZUNvbXBpbGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNvbXBpbGVyT3B0aW9ucyA9IHtcbiAgICAgIG1vZHVsZTogJ2NvbW1vbmpzJyxcbiAgICAgIHNvdXJjZU1hcDogdHJ1ZSxcbiAgICAgIGRvU2VtYW50aWNDaGVja3M6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xuICAgIHJldHVybiBpbnB1dE1pbWVUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXRPdXRwdXRNaW1lVHlwZSgpIHtcbiAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnO1xuICB9XG5cbiAgY29tcGlsZVN5bmMoc291cmNlQ29kZSwgZmlsZVBhdGgpIHtcbiAgICB0c3MgPSB0c3MgfHwgcmVxdWlyZSgnQHBhdWxjYmV0dHMvdHlwZXNjcmlwdC1zaW1wbGUnKTtcbiAgICB0cyA9IHRzIHx8IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcblxuICAgIC8vIE5COiBJZiB5b3UgZW5hYmxlIHNlbWFudGljIGNoZWNrcyB3aXRoIFRTWCwgeW91J3JlIGdvbm5hIGhhdmUgYVxuICAgIC8vICAgICBCYWQgVGltZVxuICAgIGxldCBleHRyYU9wdHMgPSB7dGFyZ2V0OiB0cy5TY3JpcHRUYXJnZXQuRVM2fTtcbiAgICBsZXQgaXNKc3ggPSBmYWxzZTtcbiAgICBpZiAoZmlsZVBhdGgubWF0Y2goL1xcLnRzeCQvaSkpIHtcbiAgICAgIGV4dHJhT3B0cy5qc3ggPSB0cy5Kc3hFbWl0LlJlYWN0O1xuICAgICAgaXNKc3ggPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5COiBXb3JrIGFyb3VuZCBUeXBlU2NyaXB0U2ltcGxlIG1vZGlmeWluZyB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICBsZXQgY29tcGlsZXIgPSBuZXcgdHNzLlR5cGVTY3JpcHRTaW1wbGUoXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBpbGVyT3B0aW9ucywgZXh0cmFPcHRzKSxcbiAgICAgIHRoaXMuY29tcGlsZXJPcHRpb25zLmRvU2VtYW50aWNDaGVja3MgJiYgIWlzSnN4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBjb21waWxlci5jb21waWxlKHNvdXJjZUNvZGUsIHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpKSxcbiAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICB9O1xuICB9XG5cbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xuICAgIHJldHVybiByZXF1aXJlKCd0eXBlc2NyaXB0L3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gIH1cbn1cbiJdfQ==